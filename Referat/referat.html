<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8" />
    <title>Node.js Реферат</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
</head>
<body>
	<div id="page-wrapper">
		<header>
			<h1>Node.js</h1>
			<h2>by Yavor Mihaylov FN: 61528</h2>
		</header>

		<article class="topic">
			<section>
				<h1>1. Node.js</h1>
				&nbsp <p>Още от създаването си JavaScript (1995) “живее” и работи в браузърите. Това е просто контекст, който дефинира какво може да се прави с езика, но не казва какво може да направи сам по себе си езика. JavaScript е “завършвен” (completed) език: може да се използва в много контексти и да се постигне всичко с него, както може да бъде постигнато с всички други “завършени ” езици.
				Node.js е просто един друг контекст, който позволява да се пусне JavaScript код в back-end частта на един или повече сайтове, извън браузъра.</p>
				<p>За да се пусне JavaScript код в back-end, трябва да се интерпретира и изпълни. В Node.js това става, чрез виртуалната машина за JavaScript на Google – V8, която се използва и в браузъра Google Chrome.
				Node.js е софтуерна система от страна на сървъра, проектирана за писане на мащабни интернет приложения, предимно web server-и. Програмите се пишат от страна на сървъра с JavaScript, използващи event-driver, asynchronous I/O за да се минимизира overhead-а и да се максимизира мащабността. </p>
				<p>Node.js създава web server oт само себе си, правейки ненужно използването на web server software, като Apache или Lighttpd. Node.js позволява пълен контрол върху това, как web server-а работи. Node.js позволява web разработчиците да създават цялостни web приложения използвайки само един език (JavaScript), и за front-end-а и за back-end-а на приложението.</p>
				<p>Node.js е пакетирана компилация от V8 JavaScript engine-а на Google, libUV аbstraction layer платформа. Създаден е от Ryan Dahl. Проекта е започнат от 2009 година и разработката и поддръжката е спонсорирана от фирма Joyent.</p>
				<p>Първоначалната цел на Dahl е да създава сайтове със push поддръжка (push capabilities, push technology), която може да видим в Gmail например. Пробвайки различни решения в няколко различни програмни езика, той избира JavaScript, поради липсата на I/O API. Това му позволява да дефинира конвенция за non-blocking, event-driven I/O.</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>2. Event-driven nature</h1>
				</p>
					&nbsp Event-driven architecture е шаблон за софтуерна архитектура, която е базирана за работа със събития. Като event може да се определи, значителна промяна на състоянието на дадено нещо. Например, когато клиент си купува кола, състоянието на колата преминава от “за продан” към “продадена”, тоест си сменя текущия status. Всяка промяна на дадено нещо може да се нарече event (събитие). Софтуерната система на продавача на коли може да третира тази промяна на състоянието като събитие (event), при което системата да направи промяна на данните в друга част от софтуерната архитектура. От формална гледна точка, когато се произведе, продаде или купи дадено нещо се изпълнява съобщение наречено event notification. Това което известява е, че самото събитие се е случило.
				</p>
				<p>
					Този архитектурен модел може да се прилага при проектирането на софтуерни системи, при които се предават събития между слабо свързани софтуерни компоненти или услуги. Event-driven системата обикновено се състои от event emmitters и event consumers или event sinks.
				</p>
				<p>
					Sink-овете имат отговорност за прилагане на реакция, веднага след като event-а настъпи. Emmitter-ите са тези при който настъпва събитието. Например, вие като цъкнете на даден бутон в даден уеб сайт, този бутон се явява Emmitter (от него произтична събитието), а sink може да всичко, което съдържа логика за обработване на това събитие, като javascript функция или php скрипт със заявка до базата данни и т.н.
				</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>3. Asynchronous I/O</h1>
				</p>
					&nbsp 	Асинхронния вход/изход в компютърните науки е форма на I/O обработка, която позволява при обработване на една операция, да започне обработка на втора, преди първата да е свършила. Входно/изходните операции в компютъра могат да бъдат много бавни. I/O устройството може да включва механични части, които трябва да се местят, като seeking операция на хард диска за четене и запис. Примерно поведение на I/O операция може да бъде: започване на операция и изчакване, докато операцията не се завърши.. Такова поведение се нарича synchronous I/O или blocking I/O, защото блокира процеса, докато програмата обработва процеса.  Когато има много I/O операции, това означава, че процесора прекарва по много време в idle, чакайки I/O операциите да завършат. 
				</p>
				<p>
					Алтернативата е да се започне комуникация и да се извърши processing, който не изисква I/O операцията да е завършена. Това поведение се нарича asynchronous input/output. Всяка задача, която всъщност зависи от I/O oперациите, които не са завършили, не може да бъде изпълнена, но пък, тези който не зависят от конкретна конкретна не изпълнена операция, може да продължи по работата си.
				</p>
				<p>
					Така можем с node.js да обработваме файлове много по-бързо, докато в сръвнение с php, това не е възможно, защото работи с blocking I/0
				</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>4. V8 JavaScript Engine</h1>
				</p>
					&nbsp 	JavaScript Engine с отворен код, разработен от Google. Използва се в браузъра Google Chrome. Първата версия излиза, когато излиза и първата версия на Google Chrome, 2ри Септември 2008.
				</p>
				<p>
					V8 компилира JavaScript до native машинен код преди изпълнението му. Както други традиционни техники като Java Virtual Machine изпълнява до bytecode или го интерпретира. Компилирания код е допълнително оптимизиран динамично в runtime въз основа на евристични методи за изпълнение на код. Използват се техники за оптимизиране като inlining, elision, inline кеширане и много други.
				</p>
				<p>
					Garbage collector-а на V8 е базиран на Generational Incremental Collector. V8 е предназначен да се използва както в браузъра така и като самостоятелен високо производителен JavaScript Enginе, който може да се интегрира в различни проекти, както е случая за Node.js.
				</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>5. NPM</h1>
				</p>
					Какво можем да наричаме npm?
					NPM конзолно приложение и също така е пакетен мениджър (Package Manger) за Node.js, който се изпълнява в терминала и управлява зависимостите (dependancies) на приложението. Node.js използва и други пакетни мениджъри, но предимно npm. Според неговия автор, npm, не е акроним от Node.js Package Manager. От версия 0.6.3, npm идва вградено заедно със средата на Node.js.
				</p>
				<p>
					V8 компилира JavaScript до native машинен код преди изпълнението му. Както други традиционни техники като Java Virtual Machine изпълнява до bytecode или го интерпретира. Компилирания код е допълнително оптимизиран динамично в runtime въз основа на евристични методи за изпълнение на код. Използват се техники за оптимизиране като inlining, elision, inline кеширане и много други.
				</p>
				<p>
					Garbage collector-а на V8 е базиран на Generational Incremental Collector. V8 е предназначен да се използва както в браузъра така и като самостоятелен високо производителен JavaScript Enginе, който може да се интегрира в различни проекти, както е случая за Node.js.
				</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>6. Тестване на node.js приложения</h1>
				</p>
					В тази част ще споменем, най-често използваните инструменти за тестване на node.js приложения:
				</p>
				<p>
					Mocha<br />
					Mocha е богат на функционалност JavaScript test framework. Може да се пусне и в node и в браузъра. Прави асинхронното тестване опростено и забавно. Mocha тестовете се изпълняват последователно и позволяват гъвкаво и детайлно отчитане на резултатите (reporting).
				</p>
				<p>
					Should.js <br />
					Обширен test framework за node. Разширява обектно-прототипния модел, като спомага на програмиста да опише, какво точно трябва да е поведението на даден обект.   Should буквално наследява концепцията assert за unit tests, като ще дадем следния пример:
				</p>
			</section>
		</article>

		<article class="topic">
			<section>
				<h1>7. Предимства, които ни дава node.js пред други web servers</h1>
				</p>
					- Бърз е. Концепцията осъществена от V8 virtual machine, прави изпълнението на JavaScript, супер бързо
				</p>
				<p>
					- Бърз by design. Повечето приложения, които пишем днес са силно обвързани с I/O процесите. Поради event-driven природата на JavaScript (и Node.js), каквото и да напишем, то е супер бързо
				</p>
				<p>
					- Един език за всичко. Всяко сериозно web приложение днес използва JavaScript, за подобряване на UI-a и UX-a. Например Facebook и Twitter използват много JavaScript за интеракциите между страниците. Имайки възможността да пишем на този език и за back-end частта от нашето приложение ни прави атеративни.
				</p>
				<p>
					- Много подходящ за уеб в реално време, тъй като Node.js е уникално пригодено за това
				</p>
			</section>
		</article>
	</div>
</body>
</html>