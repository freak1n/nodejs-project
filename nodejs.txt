Server-side JavaScript
=================================================
Със зараждането си JavaScript (1995), той "живее" и работи в браузърите. Това е просто контекст, който дефинириа какво можеш да правиш с езика, но не  казва какво може да направи езика сам по себе си. JavaScript е "завършен" (complete) език: може да се използва в много контексти и да се постигне всичко с него, както може да бъде постигнато със всички други "завършени" езици.

Node.js е просто един друг контекст, който позволява да се пусне JavaScript код в backend частта, извън браузъра. 

За да се пусне JavaScript код в backend, трябва да се интерпертира и изпълни. Това е което прави node.js чрез виртуалната машина на Google - V8, същата runtime среда (environment) за JavaScript, която се използва в Google Chrome. Плюс това Node.js пристига с много полезни модули, които помагат на програмиста да не пише всичко от начало, като например нещо, което извежда стринг на конзолата. 

От горния параграф може да се направи извода, че Node.js е две неща - runtime среда и библиотека.

"Hello World"
===================================================
Приемаме, че node е изтеглен и инсталиран. нека създадем файл helloworld.js и напишем в него console.log("hello world");. Запазваме файла и го изпълняваме през Node.js с командата node helloworld.js. На изхода на конзолата трябва да се е изписало "hello world";

Напълно "разцъфнало" web приложение със Node.js
=================================================
The use cases
-------------------------------------------------
Нека го направим просто, но реалистично: 
- Потребителя трябва да може да използва приложението с браузър
- Потребителя трябва да може да види welcome page когато напише в адрес бара "http://domain/start" който показва форма за качване на файл
- С избирането на картина за качване и подаване на формата, тази картинка трябва да бъде качена на "http://domain/upload", където тя се показва след като качването приключи.

За тази цел не искаме да пишем най-основния код и освен това искаме да е елегантен и коректен. Умишлено ще добавим още абстракция отколкото е необходимо, за да се добие представа и за изграждането на по сложни приложения с Node.js

Стек на приложението
------------------------------------------------
Нека анализираме нашето приложение. Кои части трябва да бъдат имплементирани за да отговаря на use case-овете по-горе?
- Ние искаме да поднасяме web страници, следователно имаме нужда от HTTP server
- Нашия сървър трябва отговаря различно на заявките в зависимост какъв URL се подава, значи имаме нужда от нещо като router за да map-ва request-ите за заявките. 
- За да изпълним request-ите които пристигат на сървара са били пренасочени с помощта на рутера ни трябват и request handlers за самите заявки.
- Рутера ще трябва да приема всичкata POST информация и да я даде на request handler-ите в удобна форма. Следователно ни трябва request data handling за самата информация която пристига от POST заявките.
- Ние не просто искаме да работим с request-ите от URL-а. Ние искаме и да се показва съдържание когато тези URL-и се достъпят, което означава, че ни трябва view логика която request handler-ите могат да изпратят на браузъра на потребителя.
- Потребителя ще трябва да качва картинки, значи ще имаме нужда от нещо което да управлява качването, нещо което се грижи за детайлите.

За разлика от php, където самия Apache HTTP Sever ни предоставя web страници и приема HTTP request, с Node.js не имплементираме само приложението, а и целия http server. Фактическия нашето web приложение и нашия web сървър са едни и същи.

Изграждане на стека на приложението
===================================
Базов HTTP server
----------------------------------
Node.js ни ползволява да имаме изчистен main файл, който се изпълнява с Node.js, и изчистени модули, които да се използват от главния файл и си взаймодействат помежду си.

Нека направим main file, който ще използваме за стартиране на приложението, и модулен файл, където http сервъра "живее". Концептуално е прието, че главния файл се казва "index.js", а файла със сървъра се казва "server.js".

Отваряме файла server.js и пишем кода:

var http = require("http");

http.createServer(function(request, response) {
	response.writeHead(200, {"Content-Type": "text/plain"});
	response.write("Hello World");
	response.end();
}).listen(8888);

Това е един работещ http сървър. Нека го тестваме с командата node server.js, след което го стигаме до адрес http://localhost:8888/ и трябва да ни изпише "Hello World".

Анализиране на HTTP сървъра, който написахме
---------------------------------------------
Първия ред достъпва http модул, който е част от Node.js и е достъпен през променливата http. След това извиква една от функциите на този http модул (create server). Тази фунцкия връща обекти и този обект има метод наречен listen, който приема цифрова стойност която индикира на кой порт http сървъра ще "слуша".

На функцията createServer и подаваме анонимна фунцкия като параметър, която може и да се напише по следния начин: 

var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

Сега е момента да се запитаме: Защо не го правим по този начин?

Event-driven asynchronous callbacks
====================================
За да се разбере защо едно Node.js приложение трябва да се пише по този начин (с анонимни фунцкии), трябва да се разбереме как Node.js изпълнява кода. Подхода на Node не е уникален, но в основата на модела за изпълнение е по-ралзичен от runtime среди като Python, Ruby, PHP или Java.

Нека вземем прост пример:
var result = database.query("SELECT * FROM hugetable");
console.log("Hello World");

Първия ред взима много редове от базата данни, втория извежда в конзолата "Hello World".


Нека предположим, че тази заявка към базата данни, е найстина бавнa, която трябва да прочете много редове от базата данн, което отнема няколко секунди.

Начина по който е написан този код, JavaScript интерпретатора на Node.js първо трябва да завърши с резултат от базата данни, след което да изпълни console.log() функцията. Ако това беше написана на php, щеше да работи по същия начин и потребителя трябва да чака няколко секунди за да се зареди страницата.

Въпреки това, в модела за изпълнение на php, това няма да е "глобален" проблем: уеб сървъра започва свои php процес за всеки HTTP request, която получава. Ако едно от тези request-и изведе резултат от бавната част на кода, то води до бавно зареждане на страницита за този потребител, но останалите който не влизат в тази страница, няма да бъдат засегнати.

Модела на изпълнение в Node.js е различен - има само един единствен процес. Ако там някъде в процеса има бавна заявка към базата данни, това ще афектира върху целия процес - всичко ще спре докато бавната заявка не приключи.

За да се избегне това, JavaScript, следователно Node.jsм, представят концепцията event-driven, asynchronous callbacks, чрез използване на event loop. 

Да се разбере по-добре, използваме следващия пример: 

database.query("SELECT * FROM hugetable", function(rows) {
  var result = rows;
});
console.log("Hello World");

Тук, вместо да използваме database.query() за да върнем директно резултата, подаваме анонимна функция като втори параметър.

По този начин Node.js може да управлява заявката до базата с данни асинхронно. database.query() е част от асинхронна библиотека, това е което Node.js прави: както преди, с другия код, взима заявката и я изпраща до базата с данни, но вместо да чака резултата, просто си прави бележка на ум която казва "Когато някога в настоящето, базата данни е готова и ми върне резултат от заявката, тогава аз ще изпълня този код от анонимната функция, която ми е подадена като параметър на database.query()".

След като е направена заявката до базата с данни, веднага се изпълнява console.log(), след което Node.js влиза в event loop. Node.js продължително циркулира през този loop, докато нещо друго не се случи, чакащ за събития (events). Събития, като това, бавна база с данни да върне резултат.

Това обяснява, защо нашия HTTP server има нужда от функция, която да може да "викне" входящите заявки. Ако node.js започне на сървъра и след това просто спре, чакайки за нови заявки и продължи само когато дойдат нови заявки, това би могло да бъде доста неефикасно. Ако втори потребител достъпи сървъра докато той още обслужва първия request, втория request може само да му се отговори след като първия е готов. Веднага след като имаме повече от request-и към сървъра, това няма да работи изобщо.







