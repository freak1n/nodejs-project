Server-side JavaScript
=================================================
Със зараждането си JavaScript (1995), той "живее" и работи в браузърите. Това е просто контекст, който дефинириа какво можеш да правиш с езика, но не  казва какво може да направи езика сам по себе си. JavaScript е "завършен" (complete) език: може да се използва в много контексти и да се постигне всичко с него, както може да бъде постигнато със всички други "завършени" езици.

Node.js е просто един друг контекст, който позволява да се пусне JavaScript код в backend частта, извън браузъра. 

За да се пусне JavaScript код в backend, трябва да се интерпертира и изпълни. Това е което прави node.js чрез виртуалната машина на Google - V8, същата runtime среда (environment) за JavaScript, която се използва в Google Chrome. Плюс това Node.js пристига с много полезни модули, които помагат на програмиста да не пише всичко от начало, като например нещо, което извежда стринг на конзолата. 

От горния параграф може да се направи извода, че Node.js е две неща - runtime среда и библиотека.

"Hello World"
===================================================
Приемаме, че node е изтеглен и инсталиран. нека създадем файл helloworld.js и напишем в него console.log("hello world");. Запазваме файла и го изпълняваме през Node.js с командата node helloworld.js. На изхода на конзолата трябва да се е изписало "hello world";

Напълно "разцъфнало" web приложение със Node.js
=================================================
The use cases
-------------------------------------------------
Нека го направим просто, но реалистично: 
- Потребителя трябва да може да използва приложението с браузър
- Потребителя трябва да може да види welcome page когато напише в адрес бара "http://domain/start" който показва форма за качване на файл
- С избирането на картина за качване и подаване на формата, тази картинка трябва да бъде качена на "http://domain/upload", където тя се показва след като качването приключи.

За тази цел не искаме да пишем най-основния код и освен това искаме да е елегантен и коректен. Умишлено ще добавим още абстракция отколкото е необходимо, за да се добие представа и за изграждането на по сложни приложения с Node.js

Стек на приложението
------------------------------------------------
Нека анализираме нашето приложение. Кои части трябва да бъдат имплементирани за да отговаря на use case-овете по-горе?
- Ние искаме да поднасяме web страници, следователно имаме нужда от HTTP server
- Нашия сървър трябва отговаря различно на заявките в зависимост какъв URL се подава, значи имаме нужда от нещо като router за да map-ва request-ите за заявките. 
- За да изпълним request-ите които пристигат на сървара са били пренасочени с помощта на рутера ни трябват и request handlers за самите заявки.
- Рутера ще трябва да приема всичкata POST информация и да я даде на request handler-ите в удобна форма. Следователно ни трябва request data handling за самата информация която пристига от POST заявките.
- Ние не просто искаме да работим с request-ите от URL-а. Ние искаме и да се показва съдържание когато тези URL-и се достъпят, което означава, че ни трябва view логика която request handler-ите могат да изпратят на браузъра на потребителя.
- Потребителя ще трябва да качва картинки, значи ще имаме нужда от нещо което да управлява качването, нещо което се грижи за детайлите.

За разлика от php, където самия Apache HTTP Sever ни предоставя web страници и приема HTTP request, с Node.js не имплементираме само приложението, а и целия http server. Фактическия нашето web приложение и нашия web сървър са едни и същи.

Изграждане на стека на приложението
===================================
Базов HTTP server
----------------------------------
Node.js ни ползволява да имаме изчистен main файл, който се изпълнява с Node.js, и изчистени модули, които да се използват от главния файл и си взаймодействат помежду си.

Нека направим main file, който ще използваме за стартиране на приложението, и модулен файл, където http сервъра "живее". Концептуално е прието, че главния файл се казва "index.js", а файла със сървъра се казва "server.js".

Отваряме файла server.js и пишем кода:

var http = require("http");

http.createServer(function(request, response) {
	response.writeHead(200, {"Content-Type": "text/plain"});
	response.write("Hello World");
	response.end();
}).listen(8888);

Това е един работещ http сървър. Нека го тестваме с командата node server.js, след което го стигаме до адрес http://localhost:8888/ и трябва да ни изпише "Hello World".

Анализиране на HTTP сървъра, който написахме
---------------------------------------------
Първия ред достъпва http модул, който е част от Node.js и е достъпен през променливата http. След това извиква една от функциите на този http модул (create server). Тази фунцкия връща обекти и този обект има метод наречен listen, който приема цифрова стойност която индикира на кой порт http сървъра ще "слуша".

На функцията createServer и подаваме анонимна фунцкия като параметър, която може и да се напише по следния начин: 

var http = require("http");

function onRequest(request, response) {
  response.writeHead(200, {"Content-Type": "text/plain"});
  response.write("Hello World");
  response.end();
}

http.createServer(onRequest).listen(8888);

Сега е момента да се запитаме: Защо не го правим по този начин?

Event-driven asynchronous callbacks
====================================
За да се разбере защо едно Node.js приложение трябва да се пише по този начин (с анонимни фунцкии), трябва да се разбереме как Node.js изпълнява кода. Подхода на Node не е уникален, но в основата на модела за изпълнение е по-ралзичен от runtime среди като Python, Ruby, PHP или Java.

Нека вземем прост пример:
var result = database.query("SELECT * FROM hugetable");
console.log("Hello World");

Първия ред взима много редове от базата данни, втория извежда в конзолата "Hello World".


Нека предположим, че тази заявка към базата данни, е найстина бавнa, която трябва да прочете много редове от базата данн, което отнема няколко секунди.

Начина по който е написан този код, JavaScript интерпретатора на Node.js първо трябва да завърши с резултат от базата данни, след което да изпълни console.log() функцията. Ако това беше написана на php, щеше да работи по същия начин и потребителя трябва да чака няколко секунди за да се зареди страницата.

Въпреки това, в модела за изпълнение на php, това няма да е "глобален" проблем: уеб сървъра започва свои php процес за всеки HTTP request, която получава. Ако едно от тези request-и изведе резултат от бавната част на кода, то води до бавно зареждане на страницита за този потребител, но останалите който не влизат в тази страница, няма да бъдат засегнати.

Модела на изпълнение в Node.js е различен - има само един единствен процес. Ако там някъде в процеса има бавна заявка към базата данни, това ще афектира върху целия процес - всичко ще спре докато бавната заявка не приключи.

За да се избегне това, JavaScript, следователно Node.jsм, представят концепцията event-driven, asynchronous callbacks, чрез използване на event loop. 

Да се разбере по-добре, използваме следващия пример: 

database.query("SELECT * FROM hugetable", function(rows) {
  var result = rows;
});
console.log("Hello World");

Тук, вместо да използваме database.query() за да върнем директно резултата, подаваме анонимна функция като втори параметър.

По този начин Node.js може да управлява заявката до базата с данни асинхронно. database.query() е част от асинхронна библиотека, това е което Node.js прави: както преди, с другия код, взима заявката и я изпраща до базата с данни, но вместо да чака резултата, просто си прави бележка на ум която казва "Когато някога в настоящето, базата данни е готова и ми върне резултат от заявката, тогава аз ще изпълня този код от анонимната функция, която ми е подадена като параметър на database.query()".

След като е направена заявката до базата с данни, веднага се изпълнява console.log(), след което Node.js влиза в event loop. Node.js продължително циркулира през този loop, докато нещо друго не се случи, чакащ за събития (events). Събития, като това, бавна база с данни да върне резултат.

Това обяснява, защо нашия HTTP server има нужда от функция, която да може да "викне" входящите заявки. Ако node.js започне на сървъра и след това просто спре, чакайки за нови заявки и продължи само когато дойдат нови заявки, това би могло да бъде доста неефикасно. Ако втори потребител достъпи сървъра докато той още обслужва първия request, втория request може само да му се отговори след като първия е готов. Веднага след като имаме повече от request-и към сървъра, това няма да работи изобщо.

Важно е да се отблежи, че тoзи асинхронен, single-thread, event-driven модел за изпълнение не е безкрайно мащабируем относно производителност. Това е само един от няколкото модела и той има свойте недостатъци, като това, че Node.js има един процес и може да се пусне само на едно ядро от процесора. 

Как нашия сървър обработва нашите заявки
=======================================
Нека сега разгледаме и анализираме тялото на наша функция onRequest().

Когато callback-а започне да се изпълнява и оnRequest() функцията се задейства със двата и параметъра който и се подават: request и response.

Това са обекти, и ние можем да използваме техните методи за да обработваме по-детайлно HTTP заявката и да отговорим на нея. (Например изпрати нещо по жицата обратно от сървъра до браузъра който е пратил заявката).

Нашия код прави точно това: Когато една заявка се примеме от сървъра се използва response.writeHead() функцияза да изпрати HTTP статус 200 и тип на съдържанието в HTTP отговора (content-type). response.write() функцията изпраща текст "Hello World" в тялото на HTTP oтговора (response body)

Най-накрая, викаме response.end() за да завършим нашия отговор (response).

В този момент ние не се грижим за подробностите относно заявката (request), за това и не използваме обекта request изобщо.

Намиране на място за нашия сървър модул
=========================================
За сега имаме кода на много базов HTTP сървър във файла server.js. Имаме и още един файл index.js, който ще го използваме за стартиране нашето приложение и за стартирането на други модули на приложението (като server.js файла).

Нека направим нашия server.js истински Node.js модул, който може да се използва от главния файл index.js.  

Някъде в node.js 'живее' модула наречен "http" и можем да го използваме в нашия код като го извикиаме и присвоим резултата на локална променлива. 

Това прави нашата локална променлива, обект, който се грижи за всички публични методи които http mодула ни предоставя.

Обща практика е тази локална промелнлива да се казва http.

Нека сега вкараме нашия server.js script в истински мудул. Всъшност, не трябва да променяме много. Правенето на някакъв код в модул означава, че ние искаме изнесем (export) тези части от неговата функционалност които искаме да предоставим на скриптовете, който поискат модула. 

За сега, функционалността на нашия HTTP сървър има нужните неща за експортване са прости: script-овете изискващи нашия сървър модул се нуждаят да стариртират сървъра.

За да постигнем това нещо, ние трябва да сложим нашия server коде във функция найменована start, и ние можем да exportнем тази функция.

var http = require("http");

function start() {
	function onRequest(request, response) {
		console.log("Request received.");
		response.writeHead(200, {"Content-Type": "text/plain"});
		response.write("Hello world!");
		response.end();
	}

	http.createServer(onRequest).listen(8888);
	console.log("Server has started");
}
export.start = start;


Можем да направим нашия главен файл index.js и стартираме нашия HTTP там. Въвеждаме в index.js следния код: 

var server = require("./server");
server.start();

Така можем да използваме нашия сървър модул, като всеки друг модул: чрез изискване файла и присвояването му към променлива. Той ни експортва функционалност която е достъпна за нас.

Прекрасно, сега можем да вкарема ралзични части от нашето приложение в различни файлове и да ги свършем заедно, чрез модули.

Ние всъшност имаме само първата част от нашето приложение: можеш да приемаме http requestи, но неможем да правим нищо с тях - в зависимост от URL-a на браузъра, ние трябва да реагираме по различне начин.

За твърде просто приложение, можем да направим това директно с callback функцията оnRequest(). Но нека направим малко по-голяма абстракция с цел да го направим по-интересно.

Правенето на различни http request-и в различни части от нашия код се нарича routin. За това нека направим модул наречен router.

От какво имаме нужда за route-ваме request-и.
-------------------------------------------------
Трябва да сме в състояние да подхранване искания URL и възможните GET и POST параметри в нашия рутер. И базирано на това, рутера има нужда от състояние да реши, кой код ще се изпълни. Кода който ще се изпълни е третата част на нашето приложение: колекцията от request handler-ите, който всъшност правят реалната работа когато requesta е приет.

Така, че ние трябва да разгледаме http заявките и да изведем искания url, kакто и GET/POST параметрите от тях. Това може да е спорно, дали трябва да е част от рутера или част от сървъра, или просто някой отеделн модул, но нека се съгласим да го напраим като http server за момента.

Всичката информация която искаме да използваме е достъпна от request обекта, който е подаден като пръв параметър на нашата цallback функция onRequest(). За да използваме тази информация имаме нужда от някой допълнителни Node.js модули, именувани url и querystring

URL модула предвижда методи, който ни позволяват да извадим различните части от нашия URL модул, като искания път и стринга със заявката. querystring може да се използва за да се направи разбор на низа на заявката и на различните и параметри. (картинка с url-a)

Също така можем да използваме querystringa за да парсваме тялото на POST request-а. 

Нека сега да добавим в оnRequest() функцията, логиката необходима за намиране na koj url път браузъра request-ва: 

var http = require("http");
var url = require("url");

function start() {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");
    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;

С този код нашето приложение може да разкраничи нашите requestи, базирано на URL път request - това ни позволява да мапваме request-ите към нашите request handler-и базирани на нашия URL път използващ нашия router.

В контекста на нашия приложение, ние трябва да имаме request-и za /start и /upload URLs handled за различни части от нашия код. Ние ще видим как всичко се събира заедно скоро.

Така, нека сега напишем нашия рутер (router.js):
Естествено този код не прави нищо, но това е ok за сега. Нека първо видим как да ги свържем заедно рутера и сървъра преди да сложим още логика в рутера.

Нашия HTTP сървър трябва да знае за нашия рутер и да може да се възползва от него. Ние можем да ги свържем твърдо с тази зависимост в сървара, но понеже ние научихме , че тврдия начин от нашия опит със други порграмни езици, ние ще направим нашия сървър loosely couple сървър и рутер посрдством ijecting тази зависимост.  

Нека първо разширим start() функцията в нашия сървър за да можем да разрешим присвояването на route функцията за да се използва като параметър

юvar http = require("http");
var url = require("url");

function start(route) {
  function onRequest(request, response) {
    var pathname = url.parse(request.url).pathname;
    console.log("Request for " + pathname + " received.");

    route(pathname);

    response.writeHead(200, {"Content-Type": "text/plain"});
    response.write("Hello World");
    response.end();
  }

  http.createServer(onRequest).listen(8888);
  console.log("Server has started.");
}

exports.start = start;

и нека разширим и index.js файла.

var server = require("./server");
var router = require("./router");

server.start(router.route);

Нека старираме сега нашето приложение и requestнем URL-а, можем да видим оutput-а на конзолата от HTTP сървъра 







